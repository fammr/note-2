# [Redis事务的分析及改进](https://segmentfault.com/a/1190000002594059)

## Redis的事务特性

- 为了保持简单，**redis事务保证了其中的一致性和隔离性**，**不满足原子性和持久性**。

### 原子性

- redis事务在执行的中途遇到错误，不会回滚，而是**继续**执行后续命令；（违反原子性）
- 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做；
- 比如：

```redis
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set aaa aaa
QUEUED
127.0.0.1:6379> incr aaa
QUEUED
127.0.0.1:6379> set bbb bbb
QUEUED
127.0.0.1:6379> exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
127.0.0.1:6379> get aaa
"aaa"
127.0.0.1:6379> get bbb
"bbb"

```

- 在`incr aaa`处失败了，`set aaa aaa`已成功不会回滚，`set bbb bbb`还会继续执行。

##### [为什么Redis不支持回滚](http://redisdoc.com/topic/transaction.html)

- 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。
- 以下是这种做法的优点：
  - Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。
  - 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。
- 有种观点认为 Redis 处理事务的做法会产生bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过INCR命令将键的值加上 `1` ， 却不小心加上了 `2` ， 又或者对错误类型的键执行了INCR， 回滚是没有办法处理这些情况的。
- 鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。

### 持久性

- 事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：
  - 在单纯的内存模式下，事务肯定是不持久的。
  - 在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。
  - 在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。
  - 其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。

### 隔离性和一致性

- redis事务在执行的过程中，不会处理其它命令，而是等所有命令都执行完后，再处理其它命令（满足隔离性）；
- redis事务在执行过程中发生错误或进程被终结，都能保证数据的一致性。

---

## redis事务的缺陷

- 除了不保证原子性和持久性，在实际使用中还有以下问题：

##### 遇到有查询的情况穿插在事务中间，不会返回结果

- 设置事务开始标志后，所有的命令都是queued，即使是查询指令，如果后续的更新操作需要依赖于前面的查询指令，那redis事务就无法有效的完成任务。
- 例如：

```redis
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set aaa aaa
QUEUED
127.0.0.1:6379> get bbb
QUEUED
127.0.0.1:6379> set ccc ccc
QUEUED
127.0.0.1:6379> exec
1) OK
2) "bbb"
3) OK
```

- 第二步 get a 返回的是queued，并不是a的查询结果，如果后续的set操作依赖于get的结果(存在依赖业务逻辑），就不能将get操作放在事务操作中。

**事务中的每条命令都与redis服务器进行了一次网络交互**

- redis 事务指定开始后，执行一个事务返回的都是queued，那这个入队操作是在客户端实现，还是在服务器端实现的？
- 查看源码，发现是在服务器端实现，在Redis.c中有这么一段：

```c
int processCommand(redisClient *c) {

    /* Exec the command */
    if (c->flags & REDIS_MULTI &&
        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)
    {
        queueMultiCommand(c); // 将事务中的命令都放入到队列中，然后返回"QUEUED"
        addReply(c,shared.queued);
    } else {
        if (server.vm_enabled && server.vm_max_threads > 0 &&
            blockClientOnSwappedKeys(c)) return REDIS_ERR;

        //调用该命令函数来处理命令
        call(c);
    }
    return REDIS_OK;
}
```

- 这里就涉及到客户端与服务器端的多次交互，明明是需要一次批量执行的n条命令，还需要通过多次网络交互，有些浪费。

---

## 更新操作中的查询实现

- 如果有这样的需求：在事务开始后，中间穿插有查询逻辑，那么使用redis事务（单库），无法满足这个要求。
- 可能的解决方案：
  1. 可以考虑使用多个库，读写分离，查询库只用来查询，更新库用来开事务做写操作；
  2. 不再使用redis的事务指令，自己在客户端将待执行的命令批量打包，决定是否回滚还是全部执行；这样可以在更新的间隙执行查询逻辑；而不需要将查询逻辑提前到事务指令multi之前。
  3. 将查询业务逻辑提前；严格规范代码编写要求，所有的redis查询逻辑都放在事务之外：

---

## 优化网络特性

- 将多个命令打包批量发送到redis服务器执行，减少网络交互，优化性能，可能的解决方案：
  1. 对于所有的get/set操作，可使用现有的mget/mset指令。
  2. 对于各种不同类型的更新操作，可使用lua脚本将命令打包后，发送到服务器端一次执行。

---

## [带 WATCH 的事务](http://redisbook.readthedocs.io/en/latest/feature/transaction.html)

- WATCH命令用于在事务开始之前监视任意数量的键： 当调用EXEC命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。
- 以下示例展示了一个执行失败的事务例子：

```redis
A:
127.0.0.1:6379> watch aaa
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set aaa bbb
QUEUED
127.0.0.1:6379> exec
(nil)

B:
127.0.0.1:6379> set aaa ccc
OK
```

- 以下执行序列展示了上面的例子是如何失败的：

| 时间 | 客户端A     | 客户端B     |
| ---- | ----------- | ----------- |
| T1   | watch aaa   |             |
| T2   | multi       |             |
| T3   | set aaa bbb |             |
| T4   |             | set aaa ccc |
| T5   | exec        |             |

- 在时间 T4 ，客户端 B 修改了aaa键的值， 当客户端 A 在 T5 执行EXEC时，Redis 会发现name这个被监视的键已经被修改， 因此客户端 A 的事务不会被执行，而是直接返回失败。