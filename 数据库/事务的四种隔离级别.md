# [数据库事务四种隔离级别](http://blog.csdn.net/tolcf/article/details/49283575)

### 定义

- 在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。
- **数据库事务的隔离级别有4个，由低到高依次为Read uncommitted(未授权读取、读未提交)、Read committed（授权读取、读提交）、Repeatable read（可重复读取）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。**

### 问题的提出

- 之所以提出事务隔离级别，是因为在一个事务执行过程中，可能会出现以下几种情况：

1. **更新丢失**
   - 两个事务都同时更新一行数据，一个事务对数据的更新把另一个事务对数据的更新覆盖了。
   - 这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。
2. **脏读**
   - 一个事务读取到了另一个事务未提交的数据操作结果。
3. **不可重复读**
   - 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。

- **包括以下情况：**
  1. **虚读**：
     - 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。
  2. **幻读**：
     - 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据（这里并不要求两次查询的SQL语句相同）。
     - 这是因为在两次查询过程中有另外一个事务插入数据造成的。

### 事务隔离级别

1. **Read uncommitted(未授权读取、读未提交)：**
   - 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。
   - 避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
2. **Read committed（授权读取、读提交）：**
   - 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
   - 该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
3. **Repeatable read（可重复读取）**：
   - 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
   - 避免了不可重复读取和脏读，但是有时可能出现幻读。这可以通过“共享读锁”和“排他写锁”实现。
4. **Serializable（序列化）**：
   - 提供严格的事务隔离。
     - 它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
     - 如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
   - 序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。
   - 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
     - 对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。
     - 它能够避免脏读取，而且具有较好的并发性能。
     - 尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。