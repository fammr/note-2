# [数据库范式详解](http://blog.csdn.net/IndexMan/article/details/19907731)

注：原博客有错误以及解释过于难理解，本文对其进行了修改。

- 数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的。
- 同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。

#### 第一范式（1NF）

- 第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，即数据库表中的字段都是单一属性的。

- 说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。

- 例如，如下的数据库表是符合第一范式的：

  | 姓名 | 学号 | 性别 | 年龄 |
  | ---- | ---- | ---- | ---- |
  |      |      |      |      |

- 而这样的数据库表是不符合第一范式的：

  | 姓名学号 | 性别 | 年龄 |
  | -------- | ---- | ---- |
  |          |      |      |

### 第二范式（2NF）

- 如果关系模式R为第一范式，并且R中每一个**非主属性** **完全函数依赖** 于R的某个**候选码**， 则称为第二范式模式。
- 完全函数依赖：
  - 所谓完全函数依赖是指不能存在仅依赖主关键字一部分的属性（设有函数依赖XW→A，若X→A且W→A都不成立，则称XW→A是完全函数依赖，A完全函数依赖于XW）。
  - 如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的关系模式。

##### 例子

- 假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，候选码为组合候选码(学号, 课程名称)，因为存在如下决定关系：
  - (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
- 这个数据库表不满足第二范式，因为存在如下决定关系：
  - (课程名称) → (学分)
  - (学号) → (姓名, 年龄)
- 即存在组合候选码中的部分属性决定非主属性的情况。
- 由于不符合2NF，这个选课关系表会存在如下问题：
  1. 数据冗余：
     - 同一门课程由n个学生选修，"学分"就重复n-1次；
     - 同一个学生选修了m门课程，姓名和年龄就重复了m-1次。
  2. 更新异常：
     - 若调整了某门课程的学分，数据表中所有行的"学分"值都要更新，否则会出现同一门课程学分不同的情况。
  3. 插入异常：
     - 假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有"学号"关键字，课程名称和学分也无法记录入数据库。
  4. 删除异常：
     - 假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。
- 把选课关系表SelectCourse改为如下三个表：
  - 学生：Student(学号, 姓名, 年龄)；
  - 课程：Course(课程名称, 学分)；
  - 选课关系：SelectCourse(学号, 课程名称, 成绩)。
- 这样的数据库表是符合第二范式的， 消除了数据冗余、更新异常、插入异常和删除异常。
- 另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。

###  第三范式（3NF）

- 如果关系模式R是第二范式，且每个非主属性都不传递依赖于R的候选码，则称R为第三范式模式。
- 传递函数依赖：
  - 所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。
- 因此，满足第三范式的数据库表应该不存在如下依赖关系：
  - 关键字段 → 非关键字段x → 非关键字段y。

##### 例子

- 假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字"学号"，因为存在如下决定关系：
  - (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)
- 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：
  - (学号) → (所在学院) → (学院地点, 学院电话)
- 即存在非关键字段"学院地点"、"学院电话"对关键字段"学号"的传递函数依赖。
- 它也会存在数据冗余、更新异常、插入异常和删除异常的情况，读者可自行分析得知。
- 把学生关系表分为如下两个表：
  - 学生：(学号, 姓名, 年龄, 所在学院)；
  - 学院：(学院, 地点, 电话)。
- 这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。

### 鲍依斯-科得范式（BCNF）

- 若关系模式R是第一范式，且每个属性都不传递依赖与部分依赖于R的候选码。这种关系模式就是BCNF模式。
- 即在第三范式的基础上，数据库表中如果不存在任何属性对任一候选码的传递函数依赖则符合鲍依斯-科得范式。
- 假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。
- 这个数据库表中存在如下决定关系：
  - (仓库ID, 存储物品ID) →(管理员ID, 数量)
  - (管理员ID, 存储物品ID) → (仓库ID, 数量)
- 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。
- 但是，由于存在如下决定关系：
  - (仓库ID) → (管理员ID)
  - (管理员ID) → (仓库ID)
- 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况：
  1. 删除异常：
     - 当仓库被清空后，所有"存储物品ID"和"数量"信息被删除的同时，"仓库ID"和"管理员ID"信息也被删除了。
  2. 插入异常：
     - 当仓库没有存储任何物品时，无法给仓库分配管理员。
  3. 更新异常：
     - 如果仓库换了管理员，则表中所有行的管理员ID都要修改。
- 把仓库管理关系表分解为二个关系表：
  - 仓库管理：StorehouseManage(仓库ID, 管理员ID)；
  - 仓库：Storehouse(仓库ID, 存储物品ID, 数量)。
- 这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。

### 四种范式之间存在如下关系

- BCNF⊆3NF⊆2NF⊆1NF。

| 范式 | 对比上一范式的关系                             |
| ---- | ---------------------------------------------- |
| 1NF  |                                                |
| 2NF  | 消去非主属性对候选码的部分函数依赖             |
| 3NF  | 消去非主属性对候选码的传递函数依赖             |
| BCNF | 消去主属性对候选码的部分函数依赖与传递函数依赖 |