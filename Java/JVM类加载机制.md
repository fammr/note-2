# 类加载机制

### 概述

- 虚拟机把描述类的数据从 Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

### 类加载的时机

- 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（*Loading*）、验证（*Verification*）、准备（*Preparation*）、解析（*Resolution*）、初始化（*Initialization*）、使用（*Using*）和卸载（*Unloading*）7 个阶段。
- 其中验证、准备、解析3个部分统称为连接（*Linking*），这 7 个阶段的发生顺序如所示。![](https://github.com/walmt/interview_questions/blob/master/Java/img/4.png?raw=true)

### 类加载顺序

- 加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的。类的加载过程必须按照这种顺序按部就班地开始。
- 而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再**开始**，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。
- 这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。

### 需要加载的情况

- Java 虚拟机规范中并没有进行强制约束什么情况下需要开始类加载过程，这点可以交给虚拟机的具体实现来自由把握。
- 但是对于初始化阶段，虚拟机规范则是严格规定了**有且只有** 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
  1. 遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
     - 生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（**被 final 修饰、已在编译期把结果放入常量池的静态字段除外**）的时候，以及调用一个类的静态方法的时候。
  2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
  3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类。
  5. 当使用JDK 1.7的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

### 接口的加载与类加载的不同

- 接口与类真正有所区别的是前面讲述的 5 种“有且仅有”需要开始初始化场景中的第3种：
  - 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

# 类加载的过程

### 加载

- “加载”是“类加载”（*Class Loading*）过程的一个阶段。在加载阶段，虚拟机需要完成以下 3 件事情：
  1. 通过一个类的全限定名来获取定义此类的二进制字节流。
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
- 二进制字节流可从ZIP包（如： JAR、EAR、WAR 格式）、网络、运行时计算生成（如动态代理）、由其他文件生成（如JSP）、从数据库中读取等等。

### 验证

- **验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**
- 从整体上看，验证阶段大致上会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 准备

- 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
- 这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
- 这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：`public static int value=123;`，那变量 value 在准备阶段过后的初始值为 0 而不是 123。
- 上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：
  - 如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值，假设上面类变量 value 的定义变为：`public static final int value = 123;` 。
  - 编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。

### 解析

- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在前一章讲解Class文件格式的时候已经出现过多次，在Class文件中它以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。

##### 符号引用&直接引用

- 符号引用（*Symbolic References*）：
  - 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
  - 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
  - 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。
- 直接引用（*Direct References*）：
  - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。
  - 直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。
  - 如果有了直接引用，那引用的目标必定已经在内存中存在。

### 初始化

- 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。
- 到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。
- 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。
- 或者可以从另外一个角度来表达：初始化阶段是执行类构造器`<clinit>()`方法的过程。

### `<clinit>()`方法

- `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的。
- 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
- `<clinit>()`方法与类的构造函数（或者说实例构造器＜init＞（）方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕。
- 因此在虚拟机中第一个被执行的`<clinit>()`方法的类肯定是 java.lang.Object。
- 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
- `<clinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。


- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成`<clinit>()`方法。
- 但接口与类不同的是，执行接口的`<clinit>()`方法不需要先执行父接口的`<clinit>()`方法。
- 只有当父接口中定义的变量使用时，父接口才会初始化。
- 另外，接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。


- 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确地加锁、同步。
- 如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<clinit>()`方法完毕。
- 如果在一个类的`<clinit>()`方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

# 类加载器

- 类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类加载阶段。
- 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
- 这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。
- 否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

- 这里所指的“相等”，包括代表类的 Class 对象的`equals()`方法、`isAssignableFrom()`方法、`isInstance()`方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

### 双亲委派模型

- 从Java虚拟机的角度来讲，只存在两种不同的类加载器：
  - 一种是启动类加载器（*Bootstrap ClassLoader*），这个类加载器使用C++语言实现，是虚拟机自身的一部分。
  - 是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。
- 从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分 Java 程序都会使用到以下 3 种系统提供的类加载器。
  - 启动类加载器（*Bootstrap ClassLoader*）：前面已经介绍过，这个类将器负责将存放在\<JAVA_HOME>\lib目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。
  - 扩展类加载器（*Extension ClassLoader*）：这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载<JAVA_HOME>\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
  - 应用程序类加载器（*Application ClassLoader*）：这个类加载器由 sun.misc.Launcher$App-ClassLoader 实现。
- 我们的应用程序都是由这 3 种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。
- 这些类加载器之间的关系：![](https://github.com/walmt/interview_questions/blob/master/Java/img/5.png?raw=true)
  - 这种层次关系，称为类加载器的双亲委派模型（*Parents Delegatio nModel*）。
  - 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
  - 这里类加载器之间的父子关系一般不会以继承（*Inheritance*）的关系来实现，而是都使用组合（*Composition*）关系来复用父加载器的代码。


### 工作过程

- 双亲委派模型的工作过程是：
  - 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
  - 每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
- 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。
  - 例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。
  - 相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。
  - 双亲委派模型对于保证 Java 程序的稳定运作很重要。
- 它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的`loadClass()`方法之中。


```Java
protected synchronized Class<?>loadClass(String name, boolean resolve) throws ClassNotFoundException {
    //首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if(parent != null) {
                c = parent.loadClass(name, false);
        } else {
            c = findBootstrapClassOrNull(name);
        }
    } catch (ClassNotFoundException e) {
        //如果父类加载器抛出ClassNotFoundException
        //说明父类加载器无法完成加载请求
    }
    if (c == null) {
        //在父类加载器无法加载的时候
        //再调用本身的findClass方法来进行类加载
        c = findClass(name);
        }
    }
    if(resolve) {
        resolveClass(c);
    }
    return c;
}
```

- 先检查是否已经被加载过，若没有加载则调用父加载器的`loadClass()`方法，若父加载器为空则默认使用启动类加载器作为父加载器。
- 如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的`findClass()`方法进行加载。