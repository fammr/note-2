# [理解IOC](http://blog.csdn.net/yansuoo/article/details/51234083)

### IoC是什么

- **Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。**
- 在Java开发中，**IoC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。**
- 如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：
  - **谁控制谁，控制什么：**
    - 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；
    - 而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；
    - **谁控制谁？当然是IoC 容器控制了对象；**
    - **控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。**
  - **为何是反转，哪些方面反转了**：
    - 有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；
    - 而反转则是由容器来帮忙创建及注入依赖对象；
    - 为何是反转？**因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；**
    - **哪些方面反转了？依赖对象的获取被反转了。**
  - 用图例说明一下，传统程序设计如图所示，都是主动去创建相关对象然后再组合起来：![](https://github.com/walmt/interview_questions/blob/master/Java/img/1.jpg?raw=true)
  - 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示：![](https://github.com/walmt/interview_questions/blob/master/Java/img/2.JPG?raw=true)

### IoC能做什么

- IoC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。
  - 传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；
  - 有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。
- **IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。**
- **IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。**

# IoC和DI

### IoC的别名：依赖注入（DI）

- 2004年，Martin Fowler探讨了同一个问题，既然IoC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理对象变为由IoC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection，DI）”。他的这个答案，实际上给出了实现IoC的方法：注入。
- 所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。
- 所以，依赖注入（DI）和控制反转（IoC）是从不同的角度描述的同一件事情，就是指通过引入IoC容器，利用依赖关系注入的方式，实现对象之间的解耦。

### IoC好处

- 通过控制反转（IoC）的设计模式促进了松耦合。
  - 当应用了IoC，一个对象依靠的其它对象会通过被动的方式传送进来，而不是这个对象自己创建或者查找依靠对象。
  - 不是对象从容器中查找依靠，而是容器在对象初始化时不等对象请求就主动将依靠传送给它。
  - 我们可以把IoC模式看做是工厂模式的升华，可以把IoC看作是一个大工厂，只不过这个大工厂里要生成的对象都是在配置文件中给出定义的，然后利用Java的“反射”编程，根据配置文件中给出的类名生成相应的对象。
  - 从实现来看，**IoC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。**
- 其实控制反转就是不需要我们手动new一个对象了，它把我们所要实例化的对象都写在了配置文件中了，一般这个类都是我们应用的业务类(Business Object)。
  - 框架内部已经将配置文件中配置的类自动实例化成对象，当我们调用某个类A，并且这个类中存在另一个类B时，我们就说A依靠于B，容器就会将B对象注入到A类中。以前是由类中的代码查找类并new对象，现在是配置文件控制的对象的生成，控制权由程序代码转移到了配置文件中。
  - 这样做还是有好处的，假如在A中需要5个对象，那么A类中就会new5个对象，不管以后A中用不用到这5个类，只要用到A类，就会把这5个类全部new出来。假如我们在配置文件中定义类的话，当类需要用到其中的三个类时，就会将对象注入进来，不用的就不注入进来。减少不必要的对象创建，更好的复用对象。

### IoC的缺点

1. 创建对象的步骤变复杂了，不直观，当然这是对不习惯这种方式的人来说的。
2. 因为使用反射来创建对象，所以在效率上会有些损耗。但相对于程序的灵活性和可维护性来说，这点损耗是微不足道的。
