# [JVM GC机制](https://github.com/walmt/understand_JVM/blob/master/note/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.md)

## 判断是否存活算法

### 引用计数算法

- 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1。
- 当引用失效时，计数器值就减 1。
- 任何时刻计数器为 0 的对象就是不可能再被使用的。
- 引用计数算法的实现简单，判断效率高。
- 但难解决对象之间的相互循环引用问题。

### 可达性分析算法

- 算法的基本思路就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。
- 当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。
- 在 Java 语言中，可作为 GC Roots 的对象包括下面几种：
  - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  - 方法区中类静态属性引用的对象。
  - 方法区中常量引用的对象。
  - 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。

---

## 垃圾收集算法

### 分代收集算法

- 一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集。
- 而老年代中我因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法。

### 复制算法

- 将内存划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用Eden 和其中一块 Survivor。
- 当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。
- HotSpot 默认的 Eden 和 Survivor 的大小比例是 8:1，每次新生代可用内存空间为整个新生代容量的 90% ，只有 10% 的内存会被“浪费”。

### 标记-清除算法

- 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
- 不足：
  - 效率问题，标记和清除两个过程的效率都不高。
  - 空间文件，标记清除之后会产生大量不连续的内存碎片，内存碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 标记-整理算法

- 标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。