### 悲观的并发策略——Synchronized互斥锁

##### 悲观锁

- 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

##### Synchronized

- 互斥锁是最常见的同步手段，在并发过程中，当多条线程对同一个共享数据竞争时，它保证共享数据同一时刻只能被一条线程使用，其他线程只有等到锁释放后才能重新进行竞争。
- 根据锁的颗粒度，可以用synchronized对一个变量、一个方法、一个对象和一个类等加锁。
- 被synchronized修饰的程序块经过编译后，会在前后生成monitorenter和monitorexit两个字节码指令，其中涉及到锁定和解锁对象的确定，这是根据synchronized来确定。
  - 假如明确指定了所对象，例如synchronized(变量)、synchronized(this)等，说明加解锁对象为变量或运行时对象。
  - 假如没有明确指定对象，则根据synchronized修饰的方法去找对应的锁对象，如修饰一个非静态方法表示此方法对应的对象为锁对象，如修饰一个静态方法则表示此方法对应的类对象为锁对象。
  - 当一个对象被锁住时，对象里面所有用synchronized修饰的方法都将产生堵塞，而对象里非synchronized修饰的方法可正常被调用，不收锁影响。
- Synchronized还有另外一个重要的特性——可重入性。
  - 这个特性主要是针对当前线程而言的，可重入即是自己可以再次获得自己的内部锁，在尝试获取对象锁时，如果当前线程已经拥有了此对象的锁，则把锁的计数器加一，在释放锁时则对应地减一，当锁计数器为0时表示锁完全被释放，此时其他线程可对其加锁。
- synchronized实现的是一个非公平锁，非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，当然也会产生线程饥饿现象。
- synchronized最后一个特性（缺点）就是不可中断性，在所有等待的线程中，你们唯一能做的就是等，而实际情况可能是有些任务等了足够久了，我要取消此任务去干别的事情，此时synchronized是无法帮你实现的，它把所有实现机制都交给了JVM，提供了方便的同时也体现出了自己的局限性。

### 乐观的并发策略——基于CAS的自旋

##### 乐观锁

- 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

##### CAS自旋

- 观锁的核心算法是CAS（Compareand Swap，比较并交换），它涉及到三个操作数：内存值、预期值、新值。当且仅当预期值和内存值相等时才将内存值修改为新值。
  - 这样处理的逻辑是，首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。
- `compareAndSet()`方法在Java中是使用JNI调用native方法调用由C++编写的硬件级别指令，jdk中提供了Unsafe类执行这些操作。
- 乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：
  1. 乐观锁只能保证一个共享变量的原子操作。如上例子，自旋过程中只能保证value变量的原子性，这时如果多一个或几个变量，乐观锁将变得力不从心。但可以将多个变量整合进一个对象。
  2. 长时间自旋可能导致开销大。假如CAS长时间不成功而一直自旋，会给CPU带来很大的开销。
  3.  ABA问题。CAS的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。