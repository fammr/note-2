# Java7的JVM内存分配

### 堆

- 你的Java程序中所分配的每一个对象都需要存储在内存里。堆是这些实例化的对象所存储的地方。
- 它由所有线程共享。
- 当堆耗尽的时候，JVM会抛出java.lang.OutOfMemoryError 异常。
- 堆的大小可以通过JVM选项-Xms和-Xmx来进行调整。

##### 堆的分配：

- **Eden区**
  -  新对象或者生命周期很短的对象会存储在这个区域中，这个区的大小可以通过-XX:NewSize和-XX:MaxNewSize参数来调整。
  -  新生代GC（垃圾回收器）会清理这一区域。
- **Survivor区**
  - 那些历经了Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域。
  - 这个区的大小可以由JVM参数-XX:SurvivorRatio来进行调节。
- **老年代**
  - 那些在历经了Eden区和Survivor区的多次GC后仍然存活下来的对象（当然了，是拜那些挥之不去的引用所赐）会存储在这个区里。
  - 这个区会由一个特殊的垃圾回收器来负责。
  - 年老代中的对象的回收是由老年代的GC（major GC）来进行的。

### 方法区

- 也被称为非堆区域（在HotSpot JVM的实现当中）。
- 它被分为两个主要的子区域。

##### 持久代

- 这个区域会存储包括类定义，结构，字段，方法（数据及代码）以及常量在内的类相关数据。
- 它可以通过-XX:PermSize及 -XX:MaxPermSize来进行调节。
- 如果它的空间用完了，会导致java.lang.OutOfMemoryError: PermGen space的异常。

##### 代码缓存

- 这个缓存区域是用来存储编译后的代码。
- 编译后的代码就是本地代码（硬件相关的），它是由JIT（Just In Time)编译器生成的，这个编译器是Oracle HotSpot JVM所特有的。

#### JVM栈

- 和Java类中的方法密切相关。
- 它会存储局部变量以及方法调用的中间结果及返回值。
- Java中的每个线程都有自己专属的栈，这个栈是别的线程无法访问的。
- 可以通过JVM选项-Xss来进行调整。

#### 本地栈

- 用于本地方法（非Java代码）。
- 按线程分配。

#### PC寄存器

- 特定线程的程序计数器。
- 包含JVM正在执行的指令的地址（如果是本地方法的话它的值则未定义）。

# Java8没有持久代

- 持久代已经被彻底删除了，取代它的是另一个内存区域也被称为元空间。

#### 元空间 —— 快速入门

- 它是本地堆内存中的一部分。
- 它可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来进行调整。
- 当到达XX:MetaspaceSize所指定的阈值后会开始进行清理该区域。
- 如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space的错误信息。
- 和持久代相关的JVM参数-XX:PermSize及-XX:MaxPermSize将会被忽略掉，并且在启动的时候给出警告信息。
- 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。

#### 元空间 —— 内存分配模型

- 绝大多数的类元数据的空间都从本地内存中分配。
- 用来描述类元数据的类也被删除了，分元数据分配了多个虚拟内存空间。
- 给每个类加载器分配一个内存块的列表，只进行线性分配。块的大小取决于类加载器的类型， sun/反射/代理对应的类加载器的块会小一些。
- 不会单独回收某个类，如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉。这样减少了碎片，并节省GC扫描和压缩的时间。

#### 元空间 —— 调优

- 使用-XX:MaxMetaspaceSize参数可以设置元空间的最大值，默认是没有上限的，也就是说你的系统内存上限是多少它就是多少。
- 使用-XX:MetaspaceSize选项指定的是元空间的初始大小，如果没有指定的话，元空间会根据应用程序运行时的需要动态地调整大小。
-  一旦类元数据的使用量达到了“MaxMetaspaceSize”指定的值，对于无用的类和类加载器，垃圾收集此时会触发。为了控制这种垃圾收集的频率和延迟，合适的监控和调整Metaspace非常有必要。过于频繁的Metaspace垃圾收集是类和类加载器发生内存泄露的征兆，同时也说明你的应用程序内存大小不合适，需要调整。