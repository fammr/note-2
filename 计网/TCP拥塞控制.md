# [TCP拥塞控制](http://blog.csdn.net/gogokongyin/article/details/51287985)

- 发生拥塞控制的原因：
  - 资源(带宽、交换节点的缓存、处理机)的需求>可用资源。
- 作用：
  - 拥塞控制就是为了防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载。
  - 拥塞控制要做的都有一个前提：
    - 就是网络能够承受现有的网络负荷。
- 对比流量控制：
  - 拥塞控制是一个全局的过程，涉及到所有的主机、路由器、以及降低网络相关的所有因素。
  - 流量控制往往指点对点通信量的控制，是端对端的问题。
- TCP的拥塞控制由4个核心的算法组成：
  - **慢启动**（slow start）、**拥塞避免**（Congestion voidance）、**快速重传**（Fast Retransmit）和**快速恢复**（Fast Recovery）。
- 拥塞控制，在发送方维持着一个拥塞窗口cwmd（congestion window）的状态量。
  - 拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。
  - 发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。

### 慢启动

- 由于TCP源端一开始并不知道网络资源当前的利用状况，因此新建立的TCP连接不能一开始就发送大量的数据，而只能逐步增加每次发送的数据量，以避免上述现象的发生。
- 具体来说，当新建立一个连接时，CWND初始化为1个最大报文段（MSS）大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文被确认，cwnd就增加1个MSS大小。
- 这样cwnd的值就随着网络往返时间（Round trip time，RTT）呈指数级增长，事实上，慢启动的速度一点也不慢，只是他的起点比较低一点儿而已，指数级的增长率是十分快的。
- **该算法的思想主要是一种探测一下网路的拥塞程度，就是不要一开始就发送大量的数据，也就是说有小到大逐渐增加（指数）拥塞窗口的大小。**

### 拥塞避免

- 如果按上述的慢启动的思想如果不加以控制的话，毫无疑问的发生网络拥塞，当cwnd很快增长上来的时候，也很快利用了网络的资源，但是cwnd不能一直这样增长，一定需要某个限制。
- TCP使用了一个慢启动门限（ssthresh）的变量，当cwnd超过该值后，慢启动结束，进入拥塞避免阶段。
- 对于大多数的TCP是实现来说，ssthresh的值是65535（同样以16bit来计算）。
- **拥塞避免的思想就是转指数增大变为加法线性增大。**
- 这样就可以避免增长过快导致网路拥塞，慢慢的增加调整到网络的最佳值。
- 其具体ssthresh的用法如下：
  - 当cwnd<ssthresh时，使用慢开始算法。
  - 当cwnd>ssthresh时，改用拥塞避免算法。
  - 当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

### 快速重传

- 正常情况下，消息重传是等到定时器超时（RTO）后再重传，但有时候不需要等那么久也可以重传。
- 比如客户端向服务器发送了5个段数据包，第三个丢失，其他正常，那么客户端会收到3个包2的ACK，而4、5正常到达后会被服务器缓存起来但是不会发送相应包的ACK：
  - 因为TCP是基于积累确认机制，以确保丢失的包能被重发，数据接收准确，ACK必须是连续的。
  - 这个时候就不必在等待RTO的超时时间了，服务器判断已经丢失了就可以马上快速重传，提高效率。
- **快速重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。**

### 快速恢复

- 其实快速恢复并不是单独存在的，它是快速重传的后续处理。通常认为客户端接收到3个相同的ACK后，就会开始快速重传。
  1. 当发送发连续接收到三个确认时，就执行乘法减小算法，把慢启动开始门限（ssthresh）设为当前cwnd的一半，但是接下来并不执行慢开始算法。
  2. 此时不执行慢启动算法，而是把cwnd大小设置为ssthresh， 然后执行拥塞避免算法，使拥塞窗口缓慢增大。